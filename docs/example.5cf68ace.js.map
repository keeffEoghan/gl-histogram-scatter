{"version":3,"sources":["../node_modules/@epok.tech/gl-screen-triangle/index.js","../node_modules/@epok.tech/array-utils/iterable.js","../node_modules/@epok.tech/array-utils/range.js","../node_modules/@epok.tech/array-utils/each.js","../node_modules/@epok.tech/array-utils/reduce.js","../node_modules/@epok.tech/array-utils/map.js","../node_modules/@epok.tech/array-utils/wrap-index.js","../node_modules/@epok.tech/array-utils/index.js","../index.vert.glsl","../index.frag.glsl","../index.js","../node_modules/@epok.tech/gl-screen-triangle/uv-texture.vert.glsl","test.frag.glsl","view.frag.glsl","index.js"],"names":["positions","iterable","x","Symbol","iterator","range","n","Array","fill","each","f","a","prototype","forEach","call","reduce","out","undefined","map","v","i","wrapIndex","l","wrapGet","length","module","exports","getHistogram","optionalExtensions","bitSize","byteSize","maxForBytes","bytes","valueMinMap","splitDataMap","max","min","blendMap","separatedAlpha","enable","func","srcRGB","srcAlpha","dstRGB","dstAlpha","equation","premultpliedAlpha","src","dst","normal","additive","defaultBlend","getValueMin","c","bins","color","valueMin","type","getCount","data","count","width","height","getIndexes","api","props","cache","buffer","indexes","usage","past","state","gl","prop","limits","maxA","MAX_VERTEX_TEXTURE_IMAGE_UNITS","maxB","maxVertexTextureImageUnits","maxVertexTextureUnits","console","warn","split","shape","vert","defaultVert","frag","defaultFrag","mask","blend","primitive","splitChannels","isNaN","texture","framebuffer","hasExtension","dataType","splitData","channels","Math","colorType","depth","stencil","command","attributes","index","uniforms","w","h","z","draw","regl","img","Image","image","addEventListener","imageSrc","drawTest","testFrag","position","tick","context","histogram","self","scale","drawView","viewFrag","test","fade","bars","viewProps","clear","view","frame","drawingBufferWidth","drawingBufferHeight","resize","round","document","clientX","y","clientY","innerWidth","innerHeight","log"],"mappings":"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","file":"example.5cf68ace.js","sourceRoot":"../example","sourcesContent":["/**\n * The flat array (3 vertices of a 2D triangle) to be bound as a WebGL attribute\n * buffer for rendering the triangle in the vertex shader.\n * These positions will result in clipped NDC coordinates in the range [-1, 1] over the\n * viewport's width and height.\n *\n * @export\n * @type {array.<number>}\n */\nexport const positions = [\n    -1, -1,\n    -1, 4,\n    4, -1\n];\n\nexport default positions;\n","export const iterable = (x) => (x != null) && typeof x[Symbol.iterator] === 'function';\n\nexport default iterable;\n","export const range = (n) => Array(n).fill();\n\nexport default range;\n","export const each = (f, a) => Array.prototype.forEach.call(a, f);\n\nexport default each;\n","/**\n * Reduce an array-like object.\n * Similar to native, but with iteratee-first arguments.\n * Supports the native one-value behaviour.\n *\n * Needs a fully separate `call` because native arrays detect an `undefined` parameter.\n *\n * @param {function} f The iteratee function, given standard arguments.\n * @param {array} a The array operand.\n * @param {*} [out] The initial accumulator, if given; standard behaviour, if not.\n */\nexport const reduce = (f, a, out) => ((out === undefined)?\n        Array.prototype.reduce.call(a, f)\n    :   Array.prototype.reduce.call(a, f, out));\n\nexport default reduce;\n","import { reduce } from './reduce';\n\n/**\n * Map an array-like object.\n * Similar to native, but with iteratee-first arguments; and allows the object\n * into which properties will be mapped to be defined (a new array, by default),\n * avoiding always creating new arrays.\n *\n * @param {function} f The iteratee function, given standard arguments.\n * @param {array} a The array operand.\n * @param {*} [out=[]] The initial accumulator, if given; `a`, if defined and falsey.\n */\nexport const map = (f, a, out = []) => reduce((out, v, i) => {\n        out[i] = f(v, i, a);\n\n        return out;\n    },\n    a, (out || a));\n\nexport default map;\n","export const wrapIndex = (i, l) => ((i%l)+l)%l;\n\nexport const wrapGet = (i, a) => a[wrapIndex(i, a.length)];\n\nexport default wrapIndex;\n","export * from './iterable';\nexport * from './range';\nexport * from './each';\nexport * from './reduce';\nexport * from './map';\nexport * from './wrap-index';\n","module.exports=\"precision highp float;\\n#define GLSLIFY 1\\n\\n// Output the normal bin data.\\n#define outputBins 0\\n\\n// For these tests to work, the framebuffer shape should be same as the `data` shape,\\n// instead of `split.xy`.\\n#define outputTestRead 1\\n#define outputTestBins 2\\n\\n// Switch the output mode.\\n#define outputMode outputBins\\n\\nattribute float index;\\n\\nuniform sampler2D data;\\nuniform vec2 shape;\\nuniform vec4 mask;\\n\\nuniform vec3 split;\\nuniform float count;\\nuniform float valueMin;\\n\\nvarying vec4 color;\\n\\nfloat map(float value, float inMin, float inMax, float outMin, float outMax) {\\n  return outMin + (outMax - outMin) * (value - inMin) / (inMax - inMin);\\n}\\n\\nvec2 map(vec2 value, vec2 inMin, vec2 inMax, vec2 outMin, vec2 outMax) {\\n  return outMin + (outMax - outMin) * (value - inMin) / (inMax - inMin);\\n}\\n\\nvec3 map(vec3 value, vec3 inMin, vec3 inMax, vec3 outMin, vec3 outMax) {\\n  return outMin + (outMax - outMin) * (value - inMin) / (inMax - inMin);\\n}\\n\\nvec4 map(vec4 value, vec4 inMin, vec4 inMax, vec4 outMin, vec4 outMax) {\\n  return outMin + (outMax - outMin) * (value - inMin) / (inMax - inMin);\\n}\\n\\n// The following may be overriden by macros to mix in other functions into this logic.\\n\\n#ifndef indexToUV\\n    vec2 one = vec2(1.0);\\n\\nvec2 indexToUV(in float index, in vec2 shape, in float count) {\\n    float i = index/count*shape.x*shape.y;\\n\\n    return vec2(mod(i, shape.x), floor(i/shape.x))/(shape.xy-one);\\n}\\n\\n#endif\\n\\n#ifndef dataToBin\\n    /**\\n * Scatters the data into its bin applied to `gl_Position`, with:\\n * - x: bin index (along x-axis).\\n * - y: bin data-scaled row index (along y-axis).\\n * - z: bin channel index.\\n * - w: 1\\n */\\n\\n// The following may be overriden by macros to mix in other functions into this logic.\\n\\n#ifndef binIndex\\n    // #pragma glslify: binIndex = require('./bin-index-luma');\\n    // #pragma glslify: binIndex = require('./bin-index-length');\\n    /**\\n * Scatters the data into its bin index, as the maximum channel value.\\n */\\n\\nfloat binIndexMax(in vec4 data) {\\n    return max(data[0], max(data[1], max(data[2], data[3])));\\n}\\n\\nfloat binIndexMax(in vec4 data, in vec4 mask, in vec3 split, in float index,\\n        in float count) {\\n    return binIndexMax(data*mask);\\n}\\n\\n#endif\\n\\n#ifndef binRow\\n    /**\\n * Scatters the data into its bin data-scaled row index (splitting into \\\"local\\n * histogram\\\" for higher precision in limited-size data types).\\n */\\n\\nfloat binRow(in float index, in float splitRow) {\\n    return mod(index, splitRow);\\n}\\n\\nfloat binRow(in vec4 data, in vec4 mask, in vec3 split, in float index,\\n        in float count) {\\n    return binRow(index, split.y);\\n}\\n\\n#endif\\n\\n#ifndef binChannel\\n    /**\\n * Scatters the data into its bin channel index (splitting into \\\"local histogram\\\" for\\n * higher precision in limited-size data types).\\n */\\n\\nfloat binChannel(in float index, in float splitChannels) {\\n    return mod(index, splitChannels);\\n}\\n\\nfloat binChannel(in vec4 data, in vec4 mask, in vec3 split, in float index,\\n        in float count) {\\n    return binChannel(index, split.z);\\n}\\n\\n#endif\\n\\n#ifndef binW\\n    /**\\n * Scatters the data into its bin `w` (1).\\n */\\n\\nfloat binW(in vec4 data, in vec4 mask, in vec3 split, in float index, in float count) {\\n    return 1.0;\\n}\\n\\n#endif\\n\\nvec4 dataToBin(in vec4 data, in vec4 mask, in vec3 split, in float index,\\n        in float count) {\\n    return vec4(\\n        binIndexMax(data, mask, split, index, count),\\n        binRow(data, mask, split, index, count),\\n        binChannel(data, mask, split, index, count),\\n        binW(data, mask, split, index, count)\\n    );\\n}\\n\\n#endif\\n\\n#ifndef binToColor\\n    // Sets only the selected channel to the given colour value.\\n\\nconst ivec4 channelIndeces = ivec4(0, 1, 2, 3);\\n\\nvec4 binToColor(in float channelIndex) {\\n    return vec4(equal(ivec4(int(channelIndex)), channelIndeces));\\n}\\n\\nvec4 binToColor(in float channelIndex, in float value) {\\n    return binToColor(channelIndex)*value;\\n}\\n\\n// These tie in with the values encoded by `./data-to-bin`.\\n\\nvec4 binToColor(in vec4 bin) {\\n    return binToColor(bin.z);\\n}\\n\\nvec4 binToColor(in vec4 bin, in float value) {\\n    return binToColor(bin.z, value);\\n}\\n\\n#endif\\n\\nconst float pointSize = 1.0;\\n\\n// Ranges for mapping.\\nvec4 rangeBin = vec4(vec2(0), vec2(1));\\nvec2 sizeNDC = vec2(1.0)-(pointSize/split.xy);\\nvec4 rangeNDC = vec4(-sizeNDC, sizeNDC);\\n\\nvoid main() {\\n    // Maps a vertex index to a data texture lookup UV.\\n    vec2 uv = vec2(indexToUV(index, shape, count));\\n    vec4 pixel = texture2D(data, uv);\\n\\n    // Maps a pixel of data to a vertex output `bin`.\\n    vec4 bin = vec4(dataToBin(pixel, mask, split, index, count));\\n\\n    #if outputMode == outputBins\\n        // Maps the vertex output `bin` to a point colour.\\n        color = vec4(binToColor(bin, valueMin));\\n\\n        // Map from bin coordinates to NDC less point pixels size.\\n        vec2 posXY = map(bin.xy, rangeBin.xy, rangeBin.zw, rangeNDC.xy, rangeNDC.zw);\\n\\n        // Output the vertex position and size.\\n        gl_Position = vec4(posXY, bin.zw);\\n    #else\\n        gl_Position = vec4(map(uv, rangeBin.xy, rangeBin.zw, rangeNDC.xy, rangeNDC.zw),\\n            0, 1);\\n\\n        #if outputMode == outputTestRead\\n            // Output the data read, for testing.\\n            color = pixel;\\n        #elif outputMode == outputTestBins\\n            // Output the derived bin, for testing.\\n            color = bin;\\n        #endif\\n    #endif\\n\\n    gl_PointSize = pointSize;\\n}\\n\";","module.exports=\"precision highp float;\\n#define GLSLIFY 1\\n\\nvarying vec4 color;\\n\\nvoid main() {\\n    gl_FragColor = color;\\n}\\n\";","import { map, range } from '@epok.tech/array-utils';\n\nimport defaultVert from './index.vert.glsl';\nimport defaultFrag from './index.frag.glsl';\n\nexport const optionalExtensions = ['OES_texture_half_float', 'OES_texture_float'];\n\nexport const bitSize = 2;\nexport const byteSize = 8;\n\n/**\n * Gives the range of values available for a given data scale.\n *\n * @see dataBytesMap\n *\n * @param {number} splitData Number of bytes in the data type - see `dataBytesMap`.\n * @returns {number} The number of values in the data type.\n */\nexport const maxForBytes = (bytes) => bitSize**(byteSize*bytes);\n\n/**\n * Map from texture data type to the number of bytes they have.\n *\n * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray#TypedArray_objects\n * @see https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/texImage2D\n * @see https://github.com/regl-project/regl/blob/gh-pages/API.md#texture-constructor\n *\n * @type {object.<number>}\n */\nexport const valueMinMap = {\n    // Float types (should usually be large enough)\n    ['float']: 1/maxForBytes(4),\n    ['float32']: 1/maxForBytes(4),\n    ['half float']: 1/maxForBytes(2),\n    ['float16']: 1/maxForBytes(2),\n\n    // Integer types (may need more scaling...)\n    ['uint32']: 1/maxForBytes(4),\n    ['uint16']: 1/maxForBytes(2),\n    ['uint8']: 1/maxForBytes(1)\n};\n\n/**\n * Map from texture data type to how many multiples of it should be made to get enough\n * precision. 1 means no scaling. Assumes 4 is the most scaling needed, could be more.\n *\n * @see valueMinMap\n *\n * @type {object.<number>}\n */\nexport const splitDataMap = {\n    max: 4,\n    min: 1,\n\n    // Float types (should usually be large enough)\n    ['float']: 1,\n    ['float32']: 1,\n    ['half float']: 2,\n    ['float16']: 2,\n\n    // Integer types (may need more scaling...)\n    ['uint32']: 1,\n    ['uint16']: 2,\n    ['uint8']: 4\n};\n\n/**\n * Map from alpha type to the right additive alpha blending - [tips](https://limnu.com/webgl-blending-youre-probably-wrong/).\n *\n * @type {object}\n */\nexport const blendMap = {\n    separatedAlpha: {\n        enable: true,\n        func: {\n            srcRGB: 'src alpha',\n            srcAlpha: 1,\n            dstRGB: 'one minus src alpha',\n            dstAlpha: 'one minus src alpha'\n        },\n        equation: 'add'\n    },\n    premultpliedAlpha: {\n        enable: true,\n        func: { src: 1, dst: 'one minus src alpha' },\n        equation: 'add'\n    },\n    normal: {\n        enable: true,\n        func: { src: 1, dst: 'one minus src alpha' },\n        equation: 'add'\n    },\n    additive: {\n        enable: true,\n        func: { src: 1, dst: 1 },\n        equation: 'add'\n    }\n};\n\nexport const defaultBlend = blendMap.additive;\n\n/**\n * The minimum alpha we can blend unique values over each other for the data type,\n * without saturating the bins or losing precision.\n *\n * @see valueMinMap\n *\n * @param {object.<(number | object.<array.<object.<number>>>)>} props Properties.\n * @param {number} [props.valueMin] Explicitly-set minimum value; derived if not given.\n * @param {number} [props.bins.color[0].type] Height of the `bins` output framebuffer.\n *\n * @returns {number} The count as derived from the given properties.\n */\nexport const getValueMin = ({ bins: { color: c }, valueMin }) =>\n    (valueMin || valueMinMap[c[0].type]);\n\n/**\n * The number of vertices to be drawn, derived by default from the number of pixels in\n * the input texture unless overridden.\n *\n * @param {object.<object.<[number], [number]>, [number]>} props Properties.\n * @param {number} [props.count] Explicitly-set count, if given - derived otherwise.\n * @param {number} [props.data.width] Width of the `data` input texture.\n * @param {number} [props.data.height] Height of the `data` input texture.\n *\n * @returns {number} The count as derived from the given properties.\n */\nexport const getCount = ({ data, count }) =>\n    (count || (data && (data.width*data.height)) || 0);\n\n/**\n * Update the indexes buffer if the count has increased - if it's less or equal, the\n * old buffer will be fine, not all its indexes are drawn.\n *\n * @param {object.<buffer, ...>} props Properties.\n * @param {buffer} props.in Properties.\n */\nexport function getIndexes(api, props, cache) {\n    const { buffer } = api;\n    const { data, indexes = buffer({ usage: 'dynamic' }) } = props;\n    const { count: past = 0 } = cache;\n    const count = cache.count = getCount(props);\n\n    /** @todo Rather than a full reinitialisation, [use partial buffer subdata](https://github.com/regl-project/regl/blob/gh-pages/API.md#buffer-subdata). */\n    return ((past >= count)? indexes : indexes(map((v, i) => i, range(count), 0)));\n}\n\n/**\n * @todo Use `gl_MaxVertexTextureImageUnits` in vertex shader?\n * @todo Try rendering past image directly into a vertex attribute buffer, alongside\n *     or instead of texture uniform?\n */\nexport function getHistogram(api, state, out = {}) {\n    const { gl = api, prop, buffer } = api;\n\n    const {\n            // Aliases for the same value:\n            MAX_VERTEX_TEXTURE_IMAGE_UNITS: maxA,\n            maxVertexTextureImageUnits: maxB,\n            maxVertexTextureUnits = (maxA || maxB)\n        } = (api.limits || api);\n\n    (maxVertexTextureUnits ||\n        console.warn('`gl-histogram-scatter`: need at least 1 vertex texture unit ('+\n            '`MAX_VERTEX_TEXTURE_IMAGE_UNITS`)',\n            maxVertexTextureUnits));\n\n    out = (out || state);\n\n    const cache = {\n        split: [0, 0, 0],\n        shape: [0, 0],\n        count: 0\n    };\n\n    const {\n            vert = defaultVert,\n            frag = defaultFrag,\n\n            data,\n            // A `vec4` mask to turn on or off channels read from the data texture.\n            mask = [1, 1, 1, 1],\n\n            // How many distinct values are measured in the histogram framebuffer, or\n            // a full framebuffer.\n            bins = 2**8,\n            indexes = getIndexes(api, state, cache),\n            blend = defaultBlend,\n            primitive = 'points',\n\n            // How many divisions within a bin may be used to increase the accuracy\n            // of the histogram's blended result.\n            splitChannels = 4\n        } = state;\n\n    out.vert = vert;\n    out.frag = frag;\n    out.data = data;\n    out.mask = mask;\n    out.indexes = indexes;\n    out.blend = blend;\n    out.primitive = primitive;\n    out.splitChannels = splitChannels;\n\n    if(isNaN(bins)) {\n        // Assume a provided framebuffer.\n        out.bins = bins;\n    }\n    else {\n        // Or values we can create one from with as much precision as available.\n        const { texture, framebuffer, hasExtension } = api;\n\n        const {\n                dataType = ((hasExtension('OES_texture_float'))? 'float'\n                    : ((hasExtension('OES_texture_half_float'))? 'half float'\n                    :   'uint8')),\n\n                // How many rows of bins may be used to extend the accuracy of the\n                // histogram's blended result in limited data types.\n                splitData = (splitDataMap[dataType] || 1),\n\n                // How many channels to creat in the framebuffer - by default, at least the\n                // number we may split values across, for a valid framebuffer attachment.\n                channels = Math.max(splitChannels, 3)\n            } = state;\n\n        out.bins = framebuffer({\n            color: texture({\n                width: bins,\n                // Scale the rows of bins as needed to compensate for size of data type.\n                height: splitData,\n                colorType: dataType,\n                channels\n            }),\n            depth: false,\n            stencil: false\n        });\n    }\n\n    const command = out.command = {\n        vert: prop('vert'),\n        frag: prop('frag'),\n        attributes: { index: (c, props) => getIndexes(api, props, cache) },\n        uniforms: {\n            data: prop('data'),\n            mask: prop('mask'),\n            count: (c, props) => getCount(props),\n            split: (c, { bins: { width: w, height: h }, splitChannels: z, split }) => {\n                if(!split) {\n                    ({ split } = cache);\n\n                    split[0] = w;\n                    split[1] = h;\n                    split[2] = z;\n                }\n\n                return split;\n            },\n            shape: (c, { data: { width: w, height: h }, shape }) => {\n                if(!shape) {\n                    ({ shape } = cache);\n\n                    shape[0] = w;\n                    shape[1] = h;\n                }\n\n                return shape;\n            },\n            valueMin: (c, props) => getValueMin(props)\n        },\n        blend,\n        primitive: prop('primitive'),\n        depth: { enable: false },\n        count: (c, props) => getCount(props),\n        framebuffer: prop('bins')\n    };\n\n    if(typeof gl === 'function') {\n        const draw = gl(command);\n\n        out.draw = (props = out) => draw(props);\n    }\n\n    return out;\n}\n\nexport default getHistogram;\n","module.exports=\"precision highp float;\\n#define GLSLIFY 1\\n\\nattribute vec2 position;\\n\\nvarying vec2 uv;\\n\\n// Translation for UV NDC to texture coordinates.\\nconst vec2 offset = vec2(0.5);\\n\\nvoid main() {\\n    uv = (position*0.5)+offset;\\n    gl_Position = vec4(position, 0, 1);\\n}\\n\";","module.exports=\"precision highp float;\\n#define GLSLIFY 1\\n\\nuniform sampler2D image;\\nuniform float tick;\\n\\nvarying vec2 uv;\\n\\n//\\n// Description : Array and textureless GLSL 2D/3D/4D simplex\\n//               noise functions.\\n//      Author : Ian McEwan, Ashima Arts.\\n//  Maintainer : ijm\\n//     Lastmod : 20110822 (ijm)\\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\\n//               Distributed under the MIT License. See LICENSE file.\\n//               https://github.com/ashima/webgl-noise\\n//\\n\\nvec3 mod289(vec3 x) {\\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\\n}\\n\\nvec4 mod289(vec4 x) {\\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\\n}\\n\\nvec4 permute(vec4 x) {\\n     return mod289(((x*34.0)+1.0)*x);\\n}\\n\\nvec4 taylorInvSqrt(vec4 r)\\n{\\n  return 1.79284291400159 - 0.85373472095314 * r;\\n}\\n\\nfloat snoise(vec3 v)\\n  {\\n  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\\n  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\\n\\n// First corner\\n  vec3 i  = floor(v + dot(v, C.yyy) );\\n  vec3 x0 =   v - i + dot(i, C.xxx) ;\\n\\n// Other corners\\n  vec3 g = step(x0.yzx, x0.xyz);\\n  vec3 l = 1.0 - g;\\n  vec3 i1 = min( g.xyz, l.zxy );\\n  vec3 i2 = max( g.xyz, l.zxy );\\n\\n  //   x0 = x0 - 0.0 + 0.0 * C.xxx;\\n  //   x1 = x0 - i1  + 1.0 * C.xxx;\\n  //   x2 = x0 - i2  + 2.0 * C.xxx;\\n  //   x3 = x0 - 1.0 + 3.0 * C.xxx;\\n  vec3 x1 = x0 - i1 + C.xxx;\\n  vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\\n  vec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\\n\\n// Permutations\\n  i = mod289(i);\\n  vec4 p = permute( permute( permute(\\n             i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\\n           + i.y + vec4(0.0, i1.y, i2.y, 1.0 ))\\n           + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\\n\\n// Gradients: 7x7 points over a square, mapped onto an octahedron.\\n// The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\\n  float n_ = 0.142857142857; // 1.0/7.0\\n  vec3  ns = n_ * D.wyz - D.xzx;\\n\\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)\\n\\n  vec4 x_ = floor(j * ns.z);\\n  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\\n\\n  vec4 x = x_ *ns.x + ns.yyyy;\\n  vec4 y = y_ *ns.x + ns.yyyy;\\n  vec4 h = 1.0 - abs(x) - abs(y);\\n\\n  vec4 b0 = vec4( x.xy, y.xy );\\n  vec4 b1 = vec4( x.zw, y.zw );\\n\\n  //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\\n  //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\\n  vec4 s0 = floor(b0)*2.0 + 1.0;\\n  vec4 s1 = floor(b1)*2.0 + 1.0;\\n  vec4 sh = -step(h, vec4(0.0));\\n\\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\\n\\n  vec3 p0 = vec3(a0.xy,h.x);\\n  vec3 p1 = vec3(a0.zw,h.y);\\n  vec3 p2 = vec3(a1.xy,h.z);\\n  vec3 p3 = vec3(a1.zw,h.w);\\n\\n//Normalise gradients\\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\\n  p0 *= norm.x;\\n  p1 *= norm.y;\\n  p2 *= norm.z;\\n  p3 *= norm.w;\\n\\n// Mix final noise value\\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\\n  m = m * m;\\n  return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1),\\n                                dot(p2,x2), dot(p3,x3) ) );\\n  }\\n\\nvoid main() {\\n    gl_FragColor = mix(texture2D(image, uv),\\n        vec4(\\n            sin((uv.x*tick*0.017)-(uv.y*tick*0.02)),\\n            floor(uv*10.0)/10.0,\\n            snoise(vec3(uv*3.0, tick*0.02))\\n        ),\\n        0.5);\\n}\\n\";","module.exports=\"precision highp float;\\n#define GLSLIFY 1\\n\\nuniform sampler2D test;\\nuniform sampler2D histogram;\\nuniform float fade;\\nuniform float bars;\\n\\nvarying vec2 uv;\\n\\nconst vec4 barIn = vec4(0, 0, 0, 1);\\nconst vec4 barOut = vec4(0, 0, 1, 0.2);\\n\\nvoid main() {\\n    // @todo Not sure why this needs to be flipped but it does.\\n    vec2 st = vec2(uv.x, 1.0-uv.y);\\n    vec4 pixel = texture2D(test, st);\\n\\n    gl_FragColor = pixel;\\n\\n    vec4 bin = texture2D(histogram, st);\\n\\n    vec4 bar = mix(barOut, barIn, step(uv.y, bin.r+bin.g+bin.b+bin.a));\\n\\n    gl_FragColor = mix(clamp(pixel, 0.0, 1.0),\\n        mix(clamp(vec4(bin.rgb, 1.0), 0.0, 1.0), clamp(bar, 0.0, 1.0), bars),\\n        fade);\\n}\\n\";","// Any rendering library, but made with `regl` in mind.\nimport getRegl from 'regl';\nimport positions from '@epok.tech/gl-screen-triangle';\n\nimport { getHistogram, optionalExtensions } from '../';\nimport imageSrc from './assets/baboon.png';\n\nimport vert from '@epok.tech/gl-screen-triangle/uv-texture.vert.glsl';\n\nimport testFrag from './test.frag.glsl';\nimport viewFrag from './view.frag.glsl';\n\nconst regl = getRegl({ optionalExtensions });\n\nconst framebuffer = regl.framebuffer();\n\nconst img = new Image();\nconst image = regl.texture();\n\nimg.addEventListener('load', () => image(img));\nimg.src = imageSrc;\n\nconst drawTest = regl({\n    vert,\n    frag: testFrag,\n    attributes: { position: positions },\n    uniforms: {\n        tick: regl.context('tick'),\n        image\n    },\n    count: positions.length/2,\n    framebuffer\n});\n\nconst histogram = self.histogram = getHistogram(regl, {\n        data: framebuffer.color[0],\n        // mask: [1, 1, 1, 0],\n        // splitChannels: 3\n    },\n    0);\n\nlet scale = 1;\n\nconst drawView = regl({\n    vert,\n    frag: viewFrag,\n    attributes: { position: positions },\n    uniforms: {\n        test: regl.prop('framebuffer'),\n        histogram: regl.prop('histogram.bins.color[0]'),\n        fade: regl.prop('fade'),\n        bars: regl.prop('bars')\n    },\n    count: positions.length/2\n});\n\nconst viewProps = self.viewProps = {\n    histogram,\n    framebuffer,\n    fade: 0,\n    bars: 1\n};\n\nconst clear = {\n    view: { color: [0, 0, 0, 0], depth: 1 },\n    framebuffer: { color: [0, 0, 0, 0], depth: 1, framebuffer },\n    histogram: { color: [0, 0, 0, 0], depth: 1, framebuffer: histogram.bins }\n};\n\nfunction frame({ drawingBufferWidth: w, drawingBufferHeight: h }) {\n    framebuffer.resize(w, h);\n    // histogram.bins.resize(w, h);\n\n    histogram.count = Math.round(w*h*scale);\n\n    regl.clear(clear.framebuffer);\n    regl.clear(clear.histogram);\n    regl.clear(clear.view);\n\n    drawTest();\n    histogram.draw();\n    drawView(viewProps);\n}\n\ndocument.addEventListener('mousemove', ({ clientX: x, clientY: y }) => {\n    viewProps.fade = Math.max(0, Math.min(x/innerWidth, 1));\n    scale = (1-(y/innerHeight))**5;\n\n    console.log('fade [input = 0, histogram = 1]:', viewProps.fade, 'scale:', scale);\n});\n\ndocument.addEventListener('click', () => {\n    viewProps.bars = ((!viewProps.bars) | 0);\n\n    console.log('bars:', viewProps.bars);\n});\n\nregl.frame(frame);\n"]}